name: Java CI/CD with Gradle and Docker

# 1. 실행 조건: main 브랜치에 push가 발생했을 때
on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    # 2. 실행 환경: Ubuntu 최신 버전
    runs-on: ubuntu-latest

    steps:
      # 3. 코드 다운로드 (Checkout)
      - name: Checkout
        uses: actions/checkout@v4

      # 4. JDK 21 설치
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # 5. Gradle 빌드 및 테스트
      # (Dockerfile에서 빌드하므로 이 단계는 테스트만 수행하거나 생략 가능)
      # (여기서는 GitHub Actions에서 먼저 테스트를 통과하는지 검사합니다)
      - name: Grant execute permission to gradlew
        run: chmod +x gradlew

      # ▼▼▼ 테스트를 실행하기 "전에" DB 컨테이너를 "GitHub Runner"에 띄웁니다 ▼▼▼
      - name: Start MariaDB container for testing
        run: docker compose -f docker-compose.prod.yml up -d db
        env:
           # 라즈베리파이의 .env와 동일한 내용으로 GitHub Secrets에 등록해야 합니다.
           MARIADB_ROOT_PASSWORD: ${{ secrets.MARIADB_ROOT_PASSWORD }}
           MARIADB_DATABASE: ${{ secrets.MARIADB_DATABASE }}
           MARIADB_USER: ${{ secrets.MARIADB_USER }}
           MARIADB_PASSWORD: ${{ secrets.MARIADB_PASSWORD }}
           SPRING_DB_URL: ${{ secrets.SPRING_DATASOURCE_URL }}
           SPRING_DB_USER: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
           SPRING_DB_PASS: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}

      - name: Wait for DB to be ready
        run: |
         echo "Waiting for MariaDB to start..."
         sleep 15 # DB가 뜰 때까지 15초 대기

      - name: Build and Test with Gradle
        run: ./gradlew clean build
        env:
          # --- Database ---
          SPRING_DATASOURCE_URL: ${{ secrets.SPRING_DATASOURCE_URL }}
          SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}

          # --- Twilio ---
          TWILIO_ACCOUNT_SID: ${{ secrets.TWILIO_ACCOUNT_SID }}
          TWILIO_AUTH_TOKEN: ${{ secrets.TWILIO_AUTH_TOKEN }}
          TWILIO_PHONE_NUMBER: ${{ secrets.TWILIO_PHONE_NUMBER }}

          # --- OpenAI ---
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

          # --- Server ---
          # 참고: CI/CD 테스트 환경에서는 굳이 필요 없을 수 있습니다.
          # 만약 테스트가 이 값을 사용한다면 'localhost'나 '8080' 같은 기본값을
          # Secrets 대신 직접 넣어줘도 됩니다.
          SERVER_HOST: ${{ secrets.SERVER_HOST }} # 또는 'localhost'
          SERVER_PORT: ${{ secrets.SERVER_PORT }} # 또는 '8080'

      # 6. Docker Hub 로그인
      # (GitHub 레포지토리의 Settings > Secrets에 DOCKER_USERNAME, DOCKER_PASSWORD 등록 필요)
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # 7. 도커 이미지 빌드 및 푸시
      # (arm64/amd64 교차 빌드를 위해 buildx 사용을 권장하지만,
      #  기본 Dockerfile이 다중 아키텍처 베이스 이미지를 사용하므로
      #  라즈베리파이에서 직접 빌드하는 것과 동일한 효과를 볼 수 있습니다.)
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .       # Dockerfile이 있는 위치
          push: true       # true로 설정해야 Docker Hub에 푸시됩니다.
          # ----------------------------------------------------
          # ▼▼▼ 이미지 이름표(tag) 설정 ▼▼▼
          # [내_앱_이미지_이름]을 원하는 이름(예: my-java-app)으로 꼭 바꿔주세요.
          tags: ${{ secrets.DOCKER_USERNAME }}/here4u-server:latest
          platforms: linux/arm64
          # ----------------------------------------------------

      # 8. SSH로 라즈베리파이 5 서버에 접속하여 배포
      - name: Deploy to Raspberry Pi
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}             # 라즈베리파이 IP 또는 도메인
          username: ${{ secrets.SERVER_USERNAME }}     # 라즈베리파이 접속 유저 (예: pi)
          key: ${{ secrets.SSH_PRIVATE_KEY }}          # SSH 개인키
          port: ${{ secrets.SSH_PORT }}        # SSH 포트 (기본 22)

          # 서버에서 실행할 스크립트
          script: |
            # 1. docker-compose.prod.yml 파일이 있는 폴더로 이동
            cd /home/jisu/Desktop/Here4U-sever
            
            # 2. Docker Hub에서 새 'app' 이미지 받기
            docker compose -f docker-compose.prod.yml pull app
            
            # 3. DB(db)는 놔두고 'app' 서비스만 재시작
            #    --no-deps: 의존하는 db는 재시작하지 않음
            docker compose -f docker-compose.prod.yml up -d --no-deps app